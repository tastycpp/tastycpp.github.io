<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; Land</title>
    <link>https://tastycpp.com/</link>
    <description>Recent content on C&#43;&#43; Land</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <managingEditor>oleksandr@gituliar.net (Oleksandr Gituliar)</managingEditor>
    <webMaster>oleksandr@gituliar.net (Oleksandr Gituliar)</webMaster>
    <atom:link href="https://tastycpp.com/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Numbers</title>
      <link>https://tastycpp.com/numerics/numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/numerics/numbers/</guid>
      <description>Numbers #include &amp;lt;numbers&amp;gt;&#xA;e log2e log10e pi ... </description>
    </item>
    <item>
      <title>std::string</title>
      <link>https://tastycpp.com/strings/string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/strings/string/</guid>
      <description></description>
    </item>
    <item>
      <title>unique_ptr</title>
      <link>https://tastycpp.com/mem/unique_ptr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/mem/unique_ptr/</guid>
      <description>std::unique_ptr A unique pointer is an object that owns another object through a pointer. The object is destroyed when the unique pointer is destroyed (e.g., when leaving a block scope).&#xA;Examples show/hide&#xA;Implementation std::unique_ptr is &amp;hellip;&#xA;1template&amp;lt;typename T&amp;gt; 2class uniqur_ptr { 3private: 4 T* xxx; 5} Size 16 bytes (64-bit) 8 bytes (32-bit) Layout See Also Reference template&amp;lt;class T, class D = std::default_delete&amp;lt;T&amp;gt;&amp;gt;&#xA;class unique_ptr;&#xA;template&amp;lt;class T, class D&amp;gt;&#xA;class unique_ptr&amp;lt;T[], D&amp;gt;;</description>
    </item>
    <item>
      <title>Random Numbers</title>
      <link>https://tastycpp.com/numerics/random/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/numerics/random/</guid>
      <description>Random Number Generation Subclause 28.5 defines a facility for generating (pseudo-)random numbers.&#xA;#include &amp;lt;random&amp;gt;&#xA;Random Number Distribution Uniform Distribution uniform_int_distribution uniform_real_distribution Bernoulli Distribution bernoulli_distribution binomial_distribution geometric_distribution negative_binomial_distribution Poison Distribution poisson_distribution exponential_distribution gamma_distribution weibull_distribution extreme_value_distribution Normal Distribution normal_distribution lognormal_distribution chi_squared_distribution cauchy_distribution fisher_f_distribution student_t_distribution Sampling Distribution discrete_distribution piecewise_constant_distribution piecewise_linear_distribution Engines with Predefined Parameters default_random_engine minstd_rand0 minstd_rand mt19937 mt19937_64 ranlux24 ranlux48 knuth_b Random Number Engines class linear_congruential_engine&amp;lt;UIntType, a, c, m&amp;gt; class mersenne_twister_engine class subtract_with_carry_engine Adaptors discard_block_engine independent_bits_engine shuffle_order_engine </description>
    </item>
    <item>
      <title>shared_ptr</title>
      <link>https://tastycpp.com/mem/shared_ptr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/mem/shared_ptr/</guid>
      <description>std::shared_ptr A shared pointer is an object that owns another object through a pointer, usually obtained via new. shared_ptr implements semantics of shared ownership; the last remaining owner of the pointer is responsible for destroying the object, or otherwise releasing the resources associated with the stored pointer.&#xA;Examples show/hide&#xA;Implementation std::unique_ptr is &amp;hellip;&#xA;1template&amp;lt;typename T&amp;gt; 2class shared_ptr { 3private: 4 T* xxx; 5} Size n bytes (64-bit) n/2 bytes (32-bit) Layout See Also Reference template&amp;lt;class T&amp;gt;</description>
    </item>
    <item>
      <title>std::string_view</title>
      <link>https://tastycpp.com/strings/string_view/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/strings/string_view/</guid>
      <description></description>
    </item>
    <item>
      <title>C Functions</title>
      <link>https://tastycpp.com/strings/c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/strings/c/</guid>
      <description>C-Style Functions #include &amp;lt;cctype&amp;gt;&#xA;isalnum (int c) -&amp;gt; int isalpha (int c) -&amp;gt; int isblank (int c) -&amp;gt; int iscntrl (int c) -&amp;gt; int isdigit (int c) -&amp;gt; int isgraph (int c) -&amp;gt; int islower (int c) -&amp;gt; int isprint (int c) -&amp;gt; int ispunct (int c) -&amp;gt; int isspace (int c) -&amp;gt; int isupper (int c) -&amp;gt; int isxdigit (int c) -&amp;gt; int tolower (int c) -&amp;gt; int toupper (int c) -&amp;gt; int #include &amp;lt;cstring&amp;gt;</description>
    </item>
    <item>
      <title>Numeric Arrays</title>
      <link>https://tastycpp.com/numerics/valarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/numerics/valarray/</guid>
      <description>Numeric Arrays #include &amp;lt;valarray&amp;gt;&#xA;valarray&amp;lt;T&amp;gt; slice slice_array&amp;lt;T&amp;gt; gslice gslice_array&amp;lt;T&amp;gt; mask_array&amp;lt;T&amp;gt; indirect_array&amp;lt;T&amp;gt; </description>
    </item>
    <item>
      <title>weak_ptr</title>
      <link>https://tastycpp.com/mem/weak_ptr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/mem/weak_ptr/</guid>
      <description>std::weak_ptr The weak_ptr class template stores a weak reference to an object that is already managed by a shared_ptr.&#xA;Examples show/hide&#xA;Implementation std::unique_ptr is &amp;hellip;&#xA;1template&amp;lt;typename T&amp;gt; 2class weak_ptr { 3private: 4 T* xxx; 5} Size n bytes (64-bit) n/2 bytes (32-bit) Layout See Also Reference construct unique_ptr () noexcept&#xA;unique_ptr (pointer p) noexcept&#xA;unique_ptr (const unique_ptr&amp;amp;) = delete&#xA;Disable construction from lvalue.&#xA;unique_ptr (unique_ptr&amp;amp;&amp;amp; u) noexcept&#xA;unique_ptr (nullptr_t) noexcept</description>
    </item>
    <item>
      <title>&lt;cstdlib&gt;</title>
      <link>https://tastycpp.com/numerics/cstdlib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/numerics/cstdlib/</guid>
      <description></description>
    </item>
    <item>
      <title>Reference</title>
      <link>https://tastycpp.com/mem/c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/mem/c/</guid>
      <description>Memory Functions #include &amp;lt;cstdlib&amp;gt;&#xA;The header &amp;lt;memory&amp;gt; defines several types and function templates that describe properties of pointers and pointer-like types, manage memory for containers and other template types, destroy objects, and construct objects in uninitialized memory buffers (20.2.3â€“20.2.11 and 27.11). The header also defines the templates unique_ptr, shared_ptr, weak_ptr, out_ptr_t, inout_ptr_t, and various function templates that operate on objects of these types (20.3).&#xA;create aligned_alloc (size_t alignment, size_t size) -&amp;gt; void*</description>
    </item>
    <item>
      <title>&lt;cmath&gt;</title>
      <link>https://tastycpp.com/numerics/cmath/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/numerics/cmath/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;algorithm&gt;</title>
      <link>https://tastycpp.com/algorithms/algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/algorithms/algorithm/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;atomic&gt;</title>
      <link>https://tastycpp.com/thread/atomic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/thread/atomic/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;bit&gt;</title>
      <link>https://tastycpp.com/utilities/bit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/utilities/bit/</guid>
      <description>The header provides components to access, manipulate and process both individual bits and bit sequences.</description>
    </item>
    <item>
      <title>&lt;bitset&gt;</title>
      <link>https://tastycpp.com/utilities/bitset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/utilities/bitset/</guid>
      <description>The header defines a class template and several related functions for representing and manipulating fixed-size sequences of bits.</description>
    </item>
    <item>
      <title>&lt;cstdio&gt;</title>
      <link>https://tastycpp.com/input.output/cstdio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/input.output/cstdio/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;cstdlib&gt;</title>
      <link>https://tastycpp.com/algorithms/cstdlib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/algorithms/cstdlib/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;filesystem&gt;</title>
      <link>https://tastycpp.com/input.output/filesystem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/input.output/filesystem/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;format&gt;</title>
      <link>https://tastycpp.com/utilities/format/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/utilities/format/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;fstream&gt;</title>
      <link>https://tastycpp.com/input.output/fstream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/input.output/fstream/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;functional&gt;</title>
      <link>https://tastycpp.com/utilities/functional/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/utilities/functional/</guid>
      <description>A function object type is an object type (6.8.1) that can be the type of the postfix-expression in a function call (7.6.1.3, 12.2.2.2).208 A function object is an object of a function object type. In the places where one would expect to pass a pointer to a function to an algorithmic template (Clause 27), the interface is specified to accept a function object. This not only makes algorithmic templates work with pointers to functions, but also enables them to work with arbitrary function objects.</description>
    </item>
    <item>
      <title>&lt;future&gt;</title>
      <link>https://tastycpp.com/thread/future/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/thread/future/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;iostream&gt;</title>
      <link>https://tastycpp.com/input.output/iostream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/input.output/iostream/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;memory&gt;</title>
      <link>https://tastycpp.com/algorithms/memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/algorithms/memory/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;mutex&gt;</title>
      <link>https://tastycpp.com/thread/mutex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/thread/mutex/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;numeric&gt;</title>
      <link>https://tastycpp.com/algorithms/numeric/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/algorithms/numeric/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;optional&gt;</title>
      <link>https://tastycpp.com/utilities/optional/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/utilities/optional/</guid>
      <description>Subclause 22.5 describes class template optional that represents optional objects. An optional object is an object that contains the storage for another object and manages the lifetime of this contained object, if any. The contained object may be initialized after the optional object has been initialized, and may be destroyed before the optional object has been destroyed. The initialization state of the contained object is tracked by the optional object.</description>
    </item>
    <item>
      <title>&lt;semaphore&gt;</title>
      <link>https://tastycpp.com/thread/semaphore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/thread/semaphore/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;thread&gt;</title>
      <link>https://tastycpp.com/thread/thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/thread/thread/</guid>
      <description></description>
    </item>
    <item>
      <title>&lt;tuple&gt;</title>
      <link>https://tastycpp.com/utilities/tuple/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/utilities/tuple/</guid>
      <description>Subclause 22.4 describes the tuple library that provides a tuple type as the class template tuple that can be instantiated with any number of arguments. Each template argument specifies the type of an element in the tuple. Consequently, tuples are heterogeneous, fixed-size collections of values. An instantiation of tuple with two arguments is similar to an instantiation of pair with the same two arguments. See 22.3.</description>
    </item>
    <item>
      <title>About</title>
      <link>https://tastycpp.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/about/</guid>
      <description>About page </description>
    </item>
    <item>
      <title>array</title>
      <link>https://tastycpp.com/containers/array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/array/</guid>
      <description></description>
    </item>
    <item>
      <title>deque</title>
      <link>https://tastycpp.com/containers/deque/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/deque/</guid>
      <description></description>
    </item>
    <item>
      <title>flat_map</title>
      <link>https://tastycpp.com/containers/flat_map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/flat_map/</guid>
      <description></description>
    </item>
    <item>
      <title>flat_set</title>
      <link>https://tastycpp.com/containers/flat_set/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/flat_set/</guid>
      <description></description>
    </item>
    <item>
      <title>forward_list</title>
      <link>https://tastycpp.com/containers/forward_list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/forward_list/</guid>
      <description></description>
    </item>
    <item>
      <title>list</title>
      <link>https://tastycpp.com/containers/list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/list/</guid>
      <description></description>
    </item>
    <item>
      <title>map</title>
      <link>https://tastycpp.com/containers/map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/map/</guid>
      <description>std::map Methods construct / copy map operator= iterators begin / end cbegin / cend rbegin / rend crbegin / crend capacity empty max_size size access at operator[] modifiers clear emplace emplace_hint erase extract insert insert_or_assign merge try_emplace swap map operations contains count equal_range find map lower_bound upper_bound observers key_comp value_comp Implementation Size Layout Reference Examples </description>
    </item>
    <item>
      <title>mdspan</title>
      <link>https://tastycpp.com/containers/mdspan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/mdspan/</guid>
      <description></description>
    </item>
    <item>
      <title>queue</title>
      <link>https://tastycpp.com/containers/queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/queue/</guid>
      <description></description>
    </item>
    <item>
      <title>set</title>
      <link>https://tastycpp.com/containers/set/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/set/</guid>
      <description>The std::set container in C++ is a sorted associative container that stores unique elements. Internally, it is typically implemented as a balanced binary tree (usually a Red-Black Tree). The memory layout of std::set is similar to that of std::map, but since std::set only stores keys (without associated values), its node structure is simpler.&#xA;Methods operations complexity Implementation std::set is implemented as a red-black tree &amp;ndash; a balanced binary tree.&#xA;1template&amp;lt;typename T&amp;gt; 2class set { 3 Node* myHead; // Pointer to the parent node 4 size_t mySize; // Color for Red-Black Tree (true = red, false = black) 5} 1template&amp;lt;typename T&amp;gt; 2class Node { 3 Node* myLeft; // Pointer to the left child 4 Node* myParent; // Pointer to the parent node 5 Node* myRight; // Pointer to the right child 6 char myColor; // Color for Red-Black Tree (true = red, false = black) 7 char myIsNil; // Color for Red-Black Tree (true = red, false = black) 8 T myKey; // The key element 9} std::set class:</description>
    </item>
    <item>
      <title>span</title>
      <link>https://tastycpp.com/containers/span/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/span/</guid>
      <description></description>
    </item>
    <item>
      <title>stack</title>
      <link>https://tastycpp.com/containers/stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/stack/</guid>
      <description></description>
    </item>
    <item>
      <title>std::regex</title>
      <link>https://tastycpp.com/re/regex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/re/regex/</guid>
      <description>std::basic_regex </description>
    </item>
    <item>
      <title>std::regex_match</title>
      <link>https://tastycpp.com/re/regex_match/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/re/regex_match/</guid>
      <description></description>
    </item>
    <item>
      <title>std::regex_replace</title>
      <link>https://tastycpp.com/re/regex_replace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/re/regex_replace/</guid>
      <description></description>
    </item>
    <item>
      <title>std::regex_search</title>
      <link>https://tastycpp.com/re/regex_search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/re/regex_search/</guid>
      <description>std::regex_search </description>
    </item>
    <item>
      <title>unordered_map</title>
      <link>https://tastycpp.com/containers/unordered_map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/unordered_map/</guid>
      <description>std::unordered_map Methods construct / copy unordered_map operator= iterators begin / end cbegin / cend capacity empty max_size size modifiers clear emplace emplace_hint erase extract insert insert_or_assign merge try_emplace swap observers hash_function key_eq map operations contains count equal_range find element access at operator[] bucket interface bucket_count max_bucket_count bucket_size bucket begin / end cbegin / cend hash policy load_factor max_load_factor rehash reserve Implementation Size Layout Reference Examples </description>
    </item>
    <item>
      <title>unordered_multimap</title>
      <link>https://tastycpp.com/containers/unordered_multimap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/unordered_multimap/</guid>
      <description></description>
    </item>
    <item>
      <title>unordered_multiset</title>
      <link>https://tastycpp.com/containers/unordered_multiset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/unordered_multiset/</guid>
      <description></description>
    </item>
    <item>
      <title>unordered_set</title>
      <link>https://tastycpp.com/containers/unordered_set/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/unordered_set/</guid>
      <description></description>
    </item>
    <item>
      <title>vector</title>
      <link>https://tastycpp.com/containers/vector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>oleksandr@gituliar.net (Oleksandr Gituliar)</author>
      <guid>https://tastycpp.com/containers/vector/</guid>
      <description>std::vector A vector is a sequence container that supports (amortized) constant time insert and erase operations at the end; insert and erase in the middle take linear time. Storage management is handled automatically, though hints can be given to improve efficiency.&#xA;Examples show/hide&#xA;Implementation 1template&amp;lt;typename T&amp;gt; 2class vector { 3 T* myFirst; 4 T* myLast; 5 T* myEnd; 6} myFirst - pointer to the first element (if the vector is not empty).</description>
    </item>
  </channel>
</rss>
